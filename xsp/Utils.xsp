%module{Boost::Geometry::Utils};
%package{Boost::Geometry::Utils};

%{
#include <myinit.h>

PROTOTYPES: DISABLE

opolygon*
_polygon(my_polygon)
    polygon* my_polygon
  CODE:
    RETVAL = my_polygon;
  OUTPUT:
    RETVAL

polygon*
_polygon_arrayref(my_polygon)
    opolygon* my_polygon
  CODE:
    RETVAL = my_polygon;
  OUTPUT:
    RETVAL

omultilinestring*
_multi_linestring(my_multi_linestring)
    multi_linestring* my_multi_linestring
  CODE:
    RETVAL = my_multi_linestring;
  OUTPUT:
    RETVAL

opolygon*
_read_wkt_polygon(wkt)
    std::string& wkt
  CODE:
    RETVAL = new polygon ();
    boost::geometry::read_wkt(wkt, *RETVAL);
  OUTPUT:
    RETVAL

omultilinestring*
_read_wkt_linestring(wkt)
    std::string& wkt
  CODE:
    RETVAL = new multi_linestring ();
    boost::geometry::read_wkt(wkt, *RETVAL);
  OUTPUT:
    RETVAL

multi_linestring*
polygon_linestring_intersection(my_polygon, my_linestring)
    opolygon* my_polygon
    omultilinestring* my_linestring
  CODE:
    RETVAL = new multi_linestring ();
    boost::geometry::intersection(*my_polygon, *my_linestring, *RETVAL);
  OUTPUT:
    RETVAL

std::string
_polygon_to_wkt(my_polygon)
    opolygon* my_polygon
  CODE:
    std::ostringstream output;
    output << boost::geometry::wkt(*my_polygon);
    RETVAL = output.str();
  OUTPUT:
    RETVAL

std::string
_multilinestring_to_wkt(mls)
    omultilinestring* mls
  CODE:
    std::ostringstream output;
    output << boost::geometry::wkt(*mls);
    RETVAL = output.str();
  OUTPUT:
    RETVAL

multi_linestring*
polygon_multi_linestring_intersection(my_polygon, my_linestring)
    polygon* my_polygon
    multi_linestring* my_linestring
  CODE:
    RETVAL = new multi_linestring ();
    boost::geometry::intersection(*my_polygon, *my_linestring, *RETVAL);
    delete my_polygon; // TODO: not sure if this is best place for this
    delete my_linestring; // TODO: not sure if this is best place for this
  OUTPUT:
    RETVAL

int
point_within_polygon(my_point_xy, my_polygon)
    point_xy* my_point_xy
    polygon* my_polygon
  CODE:
    RETVAL = boost::geometry::within(*my_point_xy, *my_polygon);
    delete my_polygon; // TODO: not sure if this is best place for this
    delete my_point_xy; // TODO: not sure if this is best place for this
  OUTPUT:
    RETVAL

int
point_covered_by_polygon(my_point_xy, my_polygon)
    point_xy* my_point_xy
    polygon* my_polygon
  CODE:
    RETVAL = boost::geometry::covered_by(*my_point_xy, *my_polygon);
    delete my_polygon; // TODO: not sure if this is best place for this
    delete my_point_xy; // TODO: not sure if this is best place for this
  OUTPUT:
    RETVAL

linestring*
linestring_simplify(my_linestring, tolerance)
    linestring* my_linestring
    const double tolerance
  CODE:
    RETVAL = new linestring ();
    boost::geometry::simplify(*my_linestring, *RETVAL, tolerance);
    delete my_linestring; // TODO: not sure if this is best place for this
  OUTPUT:
    RETVAL

#multi_linestring*
int
#polygon_voronoi(my_polygon, my_hole_points)
polygon_voronoi(my_polygon)
    polygon* my_polygon
#    bp_point* my_hole_points
  CODE:
    /* RETVAL = new multi_linestring (); */
    using boost::polygon::voronoi_diagram;
    std::vector<bp_segment> segments;
    ring my_ring = my_polygon->outer();
    const unsigned int line_len = boost::geometry::num_points(my_ring);

    for (unsigned int j = 1; j < line_len; j++) {
      segments.push_back(
        bp_segment(
          bp_point(my_ring[j-1].get<0>(), my_ring[j-1].get<1>()),
          bp_point(my_ring[j].get<0>(),   my_ring[j].get<1>())
        )
      );
    }

    voronoi_diagram<double> vd;
    //construct_voronoi(points.begin(), points.end(), segments.begin(), segments.end(), &vd);
    construct_voronoi(segments.begin(), segments.end(), &vd);
    RETVAL = iterate_primary_edges1(vd);
  OUTPUT:
    RETVAL
%}
